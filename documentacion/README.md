

### MI APLICACI√ìN

## REQUISITOS
Requisitos `OBLIGATORIOS` de la aplicaci√≥n:
1. Uso de `minSdk 24` ‚úÖ

2. Uso de `AndroidX` ‚úÖ

3. Aplicaci√≥n desarrollada en `Kotlin` ‚úÖ

4. Uso de `ViewModel` ‚ùå

5. Uso de `Flow` ‚ùì

6. Uso de `Coroutines` ‚ùì

7. Utilizaci√≥n `DrawerLayout/ButtomNavigationView` para crear una estructura de navegaci√≥n de app  ‚ùå
8. Crear un m√≠nimo de `3 CustomView` propia ‚ùì

9. En caso de utilizarse `di√°logos`, se tendr√° que utilizar `DialogFragments` ‚ùì

10. Disponer de una `pantalla de Settings` que permita elegir y cambiar alg√∫n `par√°metro funcional` de la app‚ùì

11. Tener al menos una acci√≥n en la `Toolbar` adem√°s de la de `Settings` ‚ùì

12. Uso de `variantes con gradle`. Se requerir√° al menos tener dos variantes diferentes, ya sea empleando `Flavors` (free, paid, staging, production, etc...) o mediante `Build Types` (debug, beta, release...). En ambos casos se requerir√° que las dos variantes contengan parte del c√≥digo completamente aislado uno de otro. Pueden ser dos features completamente diferentes o dos entornos de backend que obtengan los datos de manera distinta, en el caso de los `Flavors`, o en el caso de `Build Types` diferentes herramientas que puedan ayudar al desarrollador en diferentes escenarios, como podr√≠a ser la posibilidad de cambiar la `URL del servidor` a la que apunta la aplicaci√≥n, a√±adir una `capa de logging` o funcionalidad adicional que ayude a `detectar errores` en debug. En cualquier caso, esto son solo ejemplos para los que se pueden usar los flavors; pero cualquier uso creativo de las variantes ser√° bienvenido.

13. Los `textos, dimensiones, colores y estilos` deben residir en su `fichero de recursos` correspondiente. Usar al menos un estilo en los `layouts XML`. ‚ùì

14. Uso de permisos con `Android 6.0` ‚úÖ

15. Creaci√≥n de `una paleta de colores propia` de la aplicaci√≥n, de modo que visualmente se pueda identificar la app a un estilo visual reconocible. ‚úÖ

16. Uso de un `modo de persistencia local` adem√°s de las `Preferences DataStore` (tambi√©n obligatorio). Entre las opciones de persistencia local, se permitir√°n tanto almacenamiento en base de datos exclusivamente (`Room`) como frameworks que aporten esa soluci√≥n (`como Firebase por ejemplo`) ‚ùì

17. Uso de `ConstraintLayout`, `ViewPager` y `SwipeRefreshLayout`. ‚ùì

18. Realizaci√≥n de `peticiones web`: ya sea servicios `REST` con `Volley` o `Retrofit` o con `APIs` que se encarguen de `encapsular peticiones` como podr√≠a ser con `Amazon Web Services` por ejemplo. ‚ùì

19. Subir la aplicaci√≥n a `Google Play` (aunque sea en fase alpha o beta e invitar a los profesores) ‚ùì

## INICIO
Creo la aplicaci√≥n `TheSimpsonPlace` con una vista `Empty Activity` de `Jetpack Compose`.

1. Creaci√≥n de una `paleta de colores propia de la aplicaci√≥n`, de modo que visualmente se pueda identificar la app a un estilo visual reconocible. Ficheros `Color.kt` y `Theme.kt`. ‚úÖ

2. Los `textos, dimensiones, colores y estilos` deben residir en su `fichero de recursos` correspondiente. Usar al menos un estilo en los `layouts XML`. ‚ùå

3. `Esqueleto` del proyecto.
- Carpeta `data`: service, datasource, mapper....
- Carpeta `domain`: repository, usecases...
- Carpeta `presentation`: viewModels, views...

4. Intalaci√≥n de `dependencias` (de momento).
* 1. Serializaci√≥n: `kotlinx.serialization` para manejar `JSON`. (`@Serializable`). Utilizado por ejemplo a la hora de transformar la entidad `CharacterDto` recibida del json por otro nombres.
* 2. ConstraintLayout: `androidx.constraintlayout` y elegimos `constraintlayout-compose`. Para realizar en Compose (vistas).
* 3. ViewModel: `androidx.lifecycle` llamada `lifecycle-viewmodel-compose`. Descartamos versiones `alpha` coger la √∫ltima que no sea de este tipo. Para los ViewModels.
* 4. Navigation:  navigation compose. `androidx.navigation`.
* 5. Coil: `io.coil-kt` y aplicamos la de `coil-compose`. Carga de imaÃÅgenes de web.
* 6. Extensi√≥n de iconos: buscar `material-icons` obtener `material-icons-extended`.


### 1. Fichero `Color.kt`

Defino la paleta de colores para el estilo visual de mi app. Tanto en modo claro como modo oscuro.

```kotlin
// üé® Modo Oscuro
val BackgroundColor = Color(0xFF09184D)
val TextColor = Color(0xFFFFC107)
val BackgroundComponentColor = Color(0xFF4E5D9C)
val TextComponentColor = Color(0xFFFFFFFF)

// üé® Modo Claro
val BackgroundColorLight = Color(0xFF3B4D8B) // Azul m√°s claro que 0xFF09184D
val TextColorLight = Color(0xFFFFD54F) // Amarillo m√°s suave
val BackgroundComponentColorLight = Color(0xFF6F7ECF) // Azul m√°s claro que 0xFF4E5D9C
val TextComponentColorLight = Color(0xFF000000) // Negro (para contraste en claro)
```

### 2. Fichero `Theme.kt`

A√±ado los colores en los temas.
```kotlin
private val DarkColorScheme = darkColorScheme(
    primary = BackgroundColor, // Color principal
    secondary = BackgroundComponentColor, // Color para elementos secundarios
    background = BackgroundColor, // Color de fondo de la app
    surface = BackgroundComponentColor, // Color de fondo de los componentes
    onPrimary = TextColor, // Color del texto sobre el color primario
    onSecondary = TextComponentColor, // Color del texto sobre el color secundario
    onBackground = TextComponentColor, // Color del texto sobre el fondo
    onSurface = TextComponentColor // Color del texto sobre los componentes
)

private val LightColorScheme = lightColorScheme(
    primary = BackgroundColorLight, // Color principal m√°s claro
    secondary = BackgroundComponentColorLight, // Color para elementos secundarios m√°s claro
    background = BackgroundColorLight, // Color de fondo de la app m√°s claro
    surface = BackgroundComponentColorLight, // Color de fondo de los componentes m√°s claro
    onPrimary = TextColorLight, // Color del texto sobre el color primario m√°s claro
    onSecondary = TextComponentColorLight, // Color del texto sobre el color secundario m√°s claro
    onBackground = TextComponentColorLight, // Color del texto sobre el fondo m√°s claro
    onSurface = TextComponentColorLight // Color del texto sobre los componentes m√°s claro
)

```

Desactivo los colores din√°micos, para usar exclusivamente los colores de `DarkColorScheme` y `LightColorScheme`

```kotlin
@Composable
fun TheSimpsonPlaceTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean =  false, // ‚ùå Desactiva los colores din√°micos, usar√° exclusivamente los colores de DarkColorScheme y LightColorScheme.
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

Ahora mi app tiene un `modo claro` con `tonos m√°s suaves`, diferenci√°ndose del `modo oscuro` sin perder `identidad visual`.



### 3. Fichero `Logger.kt`


ME QUEDAN EL LOGGER, IMPLEMENTAR PARA LOS OTROS SECCIONES, PASAR A REALIZAR LAS PANTALLAS BONITAS.


### X. DUDAS

#### 1. DUDA
@@@@ DUDA @@@@
Tengo mis dudas al intentar formar mi aplicaci√≥n (`3.`):
En cuanto al esqueleto de mi aplicaci√≥n: tengo 3 carpetas principales `data`, `domain` y `presentation`.

* Carpeta `Data`: de momento contiene:

- La subcarpeta `entities` a `CharacterDao.kt` (datos de com recibo una entidad del json de characters), `ImagenDto.kt` (datos de como recibo una entidad del json de imagenes), `Gender.kt` (enumerado con funci√≥n para pasar de string a ese enumerado).

- La subcarpeta `mapper` donde tengo `CharacterMapper.kt` con una extensi√≥n para pasar de `CharacterDto` a `Character` que es como trabajare en el domain.

- La subcarpeta `sources` la cual no se si esto es adecuado pero he hecho es dividir en dos carpetas:

+ Una subcarpeta `local` donde mi idea es obtener `los personajes del json` donde tengo un `CharacterDao.kt` con la `interface` y tiene `una funci√≥n` de obtener todos personajes (**voy a necesitar `otra funci√≥n` para filtrar por nombres de personajes pero no se si es adecuado incluirla aqui o mas adelante**).
`CharacterDaoJsonProd.kt` y `CharacterDaoJsonTest.kt` son dos de las implemanciones de la interface para obtener la funcion de los personajes.

+ Una subcarpeta `db` con lo mismo pero con la interface `CharacterDBDao.kt` y las funciones que tiene para los `characters` pero de en la `BD` y su correspondiente implementaci√≥n. **¬øEsta bien separarlos en dos `daos` diferentes? Uno con la l√≥gica deo obbtenci√≥n de datos y el otro con la de la BD o hay una mejor estructura?**

* La carpeta `domain` que de momento contiene:

- La subcarpeta `entities` con `Character.kt` que es el la entidad de personaje final con la que quiero trabajar tanto para la base de datos como la extraccion principal de los datos.

- La subcarpeta `repository` donde solo tengo una `interface` con el `CharacterRepository` con todas las funciones tanto del `dao` del `json` como para la del `dao` de la `base de datos` y he a√±adido `la nueva funci√≥n para filtrar por nombre` los personajes que se obtienen del json (no se la puse en el dao del json) **¬øEsta bien ponerla aqui o mejor era antes en el dao o despu√©s mas adelante ya en el view model?** Luego tengo la implentaci√≥n de ese dao `CharacterRepositoryImpl.kt` donde paso por paremetro las interfaces de los dos daos anteriores e implemento el `CharacterRepository`, aqui me surge otra vez **la duda al implementarse la funci√≥n de `filterCharacters` de filtrar los personajes tendria que realizar toda la funci√≥n de obtener todos los personajes y luego filtrarlo algo que no se si es buen en rendimiento por ello no se si deber√≠a estar.**

- La subcarpeta `usescases`: tengo todos los casos de uso de la interface `CharaterRepository.kt`, cada uno en una interfaz diferente y una carpeta `impl` con la implementaci√≥n de cada caso de uso pasandoloe por par√°metro el `CharaterRepository.kt`.

* La carpeta `presentation`: de momento solo esta creada dicha carpeta.
- La subcarpeta `ui` contiene a su vez
+ La subcarpeta `components` con vistas reutilizables en varias vistas principales como `BottomBar`, `TopBar` o `Icono dinamico` dependiendo de una variable por par√°metro.
+ La subcarpeta `screens` con otras carpetas donde divido la carpeta por secciones chracter, episode, menu, profile y quote. Tambien tiene el fichero de la actividad principal y unica de la aplicaci√≥n y un fichero Navegation el cual es una vista con toda la navegacion de la aplicaci√≥n (es la vista que se pasa  a la actividad).
+ La subcarpeta `themes` con los ficheros de configuraci√≥n de color, tema, tipografia...
+ La subcarpeta `viewmodel` donde de momento no hay anda pero se encontraran los ficheros de estaod d ela interfaz junto los view models de cada seccion de vistas.

* La carpete `utils` seperada de las tres capas de la aplicaci√≥n de momento solo tengo una inteerfaz `Logger.kt` con los posibles logger de la aplicaci√≥n. **¬øQue te parece la distribuci√≥n de los casos de uso en la capa del `domain`, y el esquema de capa de `presentacion`? Que me recomiendas cambiar o esta bien como esta? Es mi primera app y quiero tener una arquitectura lo mas clara, escalable y manenible posible.**

@@@@ SOLUCI√ìN GHAT GPT @@@@
Tu estructura `Data - Domain - Presentation` est√° bien planteada y sigue las mejores pr√°cticas de `Clean Architecture` en `Kotlin` con `Jetpack Compose`.

üìå 1. Estructura en la capa `data`

Actualmente tienes:
‚Ä¢ entities/ ‚Üí CharacterDto, ImageDto, Gender ‚úÖ Bien.
‚Ä¢ mappers/ ‚Üí CharacterMappers ‚úÖ Bien.
‚Ä¢ sources/local/ ‚Üí CharacterDao, CharacterDaoImpl üõë
‚Ä¢ sources/db/ ‚Üí CharacterDBDao, CharacterDBDaoImpl üõë

üîπ ¬øEst√° bien separar `DAO` del `JSON` y `DAO` de la `BD`?
‚úÖ S√≠, est√° bien porque:
1.	El JSON no es una BD real, solo es una fuente de datos est√°tica.
2.	`Separar responsabilidades` evita que `ambas fuentes` se mezclen en una misma clase.
3.	Si en el futuro usas Retrofit en vez de JSON local, el Dao del JSON ya no ser√≠a necesario.

üöÄ Mejora: **Puedes renombrar `CharacterDao.kt` ‚Üí `CharacterJsonSource.kt` y `CharacterDBDao.kt` ‚Üí `CharacterDatabaseSource.kt` para que quede m√°s claro.**

üìå 2. Estructura en la capa `domain`

Actualmente tienes:
‚Ä¢ entities/ ‚Üí Character ‚úÖ Bien.
‚Ä¢ repository/
    ‚Ä¢ CharacterRepository (interfaz) üõë
    ‚Ä¢ impl/ ‚Üí CharacterRepositoryImpl (implementaci√≥n) üõë
‚Ä¢ usecases/ ‚Üí Cada caso de uso en una interfaz distinta
	‚Ä¢ impl/ ‚Üí Implementaci√≥n de cada caso de uso pasando CharacterRepository

üîπ ¬øD√≥nde debe ir `filterCharacters(nombre)`?
üî∏ Si es un `simple filtro` sobre la lista obtenida, puede estar en `RepositoryImpl.kt`.
üî∏ Si en `el futuro la API` permite filtrar, deber√≠a ir en `CharacterJsonSource.kt` para no cargar la app de datos innecesarios.

üöÄ Mejora recomendada: **Si el `JSON nunca cambiar√°` ‚Üí d√©jalo en `RepositoryImpl.kt`. Pero si el `JSON es una API` o puede llegar a serlo en el futuro puede `permitir filtrar` ‚Üí Ponlo en `CharacterJsonSource.kt`.**

‚ùó Rendimiento
Si la lista de personajes es grande, filtrar despu√©s de cargar no es √≥ptimo. En ese caso, es mejor:
1.	Cargar solo los que coincidan ‚Üí Implementa `filterCharacters(name: String)` en `CharacterJsonSource.kt`.
2.	Guardar personajes en `BD local` y aplicar `filtros all√≠`.

üìå Casos de uso
‚úÖ Puntos positivos
‚úîÔ∏è Separaci√≥n clara de la l√≥gica de negocio.
‚úîÔ∏è Cumple el `principio de responsabilidad √∫nica` (cada caso de uso hace una sola cosa).
‚úîÔ∏è Permite `testear` cada caso de uso de `forma independiente`.

üìå 3. Estructura en `presentation`

Actualmente tienes:
‚Ä¢ üìÇ components/ ‚Üí Vistas reutilizables ‚úÖ
‚Ä¢ üìÇ screens/ ‚Üí Divisi√≥n por secciones ‚úÖ
‚Ä¢ üìÇ themes/ ‚Üí Colores, tipograf√≠a, etc. ‚úÖ
‚Ä¢ üìÇ viewmodel/ ‚Üí (A√∫n vac√≠o, pero pensado para ViewModels) ‚úÖ

‚úÖ Puntos positivos
‚úîÔ∏è Buena separaci√≥n de responsabilidades.
‚úîÔ∏è Divisi√≥n clara de screens por secciones.
‚úîÔ∏è Uso de components para evitar c√≥digo duplicado.
‚úîÔ∏è Carpeta themes bien ubicada.

‚ö†Ô∏è Posibles mejoras
üìå 1. Mover Navegation a una carpeta navigation/ dentro de presentation/ui
‚Ä¢ La navegaci√≥n no es exactamente una screen, sino una estructura que maneja las pantallas.
‚Ä¢ Crear üìÇ ui/navigation/ ‚Üí Mover Navegation.kt all√≠.

üìå 2. La actividad principal en una carpeta root/ dentro de presentation/ui
‚Ä¢ üìÇ ui/root/ ‚Üí MainActivity.kt
‚Ä¢ üìå Esto deja screens/ solo con pantallas reales y mejora la organizaci√≥n.

üìå 3. ViewModels bien organizados en viewmodel/
‚Ä¢ üìÇ viewmodel/character/CharacterViewModel.kt
‚Ä¢ üìÇ viewmodel/episode/EpisodeViewModel.kt
‚Ä¢ üìÇ viewmodel/profile/ProfileViewModel.kt
‚Ä¢ üìå Esto ayuda a encontrar r√°pidamente el ViewModel de cada secci√≥n.

üìå 4. Estructura en `utils`

Actualmente tienes:
	‚Ä¢	üìÇ utils/ ‚Üí Logger.kt

‚úÖ Puntos positivos
‚úîÔ∏è Centraliza funciones reutilizables.

‚ö†Ô∏è Posibles mejoras
üìå Si Logger.kt solo se usa en data, tal vez deber√≠a ir en data/utils/.
üìå Si utils/ tendr√° m√°s funciones reutilizables (como extensiones de Strings, Dates, etc.), entonces est√° bien en root/utils/.

üéØ Conclusi√≥n
‚úÖ Tu arquitectura est√° bien, solo hay que ajustar algunas responsabilidades.
‚úÖ S√≠, es correcto separar el DAO del JSON y el de la BD.
‚úÖ Filtrar personajes en el RepositoryImpl est√° bien, pero si el JSON puede filtrar, mejor en CharacterJsonSource.
‚úÖ Si tienes una BD, filtrar all√≠ es mejor por rendimiento.

üöÄ Recomendaciones finales:
üîπ Renombrar CharacterDao ‚Üí CharacterJsonSource y CharacterDBDao ‚Üí CharacterDatabaseSource.
üîπ Si el JSON es est√°tico, filtrar en RepositoryImpl.
üîπ Si es API, filtrar en CharacterJsonSource.
üîπ Si usas BD local, filtrar en la base de datos.
‚úîÔ∏è En domain: Usar clases de un solo m√©todo en vez de interfaces para los casos de uso.
‚úîÔ∏è En presentation: Mover Navegation.kt a navigation/ y MainActivity.kt a root/.
‚úîÔ∏è En viewmodel/: Organizar los ViewModels en subcarpetas por secciones.
‚úîÔ∏è En utils/: Mantenerlo solo si tendr√° m√°s funcionalidades reutilizables.

### 2. DUDA
@@@@ DUDA @@@@
Debe solo tener una implementaci√≥n de `CharacterDao` para ficheros json, mediante una variable que se pase el json por par√°metro para saber si es el `json de test` o de `producci√≥n`? Ese parametro deve de ser `val` o no?

@@@@ SOLUCI√ìN GHAT GPT @@@@
üìå 1. Sobre el uso de `val json: String`

En este caso, s√≠ es correcto usar `val json: String` en el constructor, porque:
‚úÖ Es un `dato inmutable` ‚Üí Una vez que pasas el json, no cambiar√°.
‚úÖ Hace `la clase m√°s reutilizable` ‚Üí Puedes usar un JSON diferente para `testing` y `producci√≥n`.

üìå Cu√°ndo usar `val` en `par√°metros del constructor`
1. ‚úÖ SI USAR `val` ‚Üí Si el par√°metro se usar√° `dentro de la clase` como una `propiedad`.

```kotlin
    class CharacterDaoJson(val json: String) // Se usa dentro de la clase
```

2. ‚ùå NO USAR val ‚Üí Si solo se pasa como argumento y no necesitas guardarlo en la clase.
```kotlin
    class CharacterDaoJson(json: String) { // json NO se guarda en la clase
        fun getAllCharacters(): List<CharacterDto> {
            val data = json // Aqu√≠ lo usas solo dentro de la funci√≥n
            return listOf() // L√≥gica de parsing
        }
    }
```

En tu caso, como `json es una propiedad que usar√°s en m√∫ltiples funciones`, debe ser `val`.

### 3. DUDA
...
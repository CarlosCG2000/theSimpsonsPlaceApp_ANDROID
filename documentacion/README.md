

### MI APLICACI√ìN

## REQUISITOS
Requisitos `OBLIGATORIOS` de la aplicaci√≥n:
1. Uso de `minSdk 24` ‚úÖ

2. Uso de `AndroidX` ‚úÖ

3. Aplicaci√≥n desarrollada en `Kotlin` ‚úÖ

4. Uso de `ViewModel` ‚ùå

5. Uso de `Flow` ‚ùì

6. Uso de `Coroutines` ‚ùì

7. Utilizaci√≥n `DrawerLayout/ButtomNavigationView` para crear una estructura de navegaci√≥n de app  ‚ùå
8. Crear un m√≠nimo de `3 CustomView` propia ‚ùì

9. En caso de utilizarse `di√°logos`, se tendr√° que utilizar `DialogFragments` ‚ùì

10. Disponer de una `pantalla de Settings` que permita elegir y cambiar alg√∫n `par√°metro funcional` de la app‚ùì

11. Tener al menos una acci√≥n en la `Toolbar` adem√°s de la de `Settings` ‚ùì

12. Uso de `variantes con gradle`. Se requerir√° al menos tener dos variantes diferentes, ya sea empleando `Flavors` (free, paid, staging, production, etc...) o mediante `Build Types` (debug, beta, release...). En ambos casos se requerir√° que las dos variantes contengan parte del c√≥digo completamente aislado uno de otro. Pueden ser dos features completamente diferentes o dos entornos de backend que obtengan los datos de manera distinta, en el caso de los `Flavors`, o en el caso de `Build Types` diferentes herramientas que puedan ayudar al desarrollador en diferentes escenarios, como podr√≠a ser la posibilidad de cambiar la `URL del servidor` a la que apunta la aplicaci√≥n, a√±adir una `capa de logging` o funcionalidad adicional que ayude a `detectar errores` en debug. En cualquier caso, esto son solo ejemplos para los que se pueden usar los flavors; pero cualquier uso creativo de las variantes ser√° bienvenido.

13. Los `textos, dimensiones, colores y estilos` deben residir en su `fichero de recursos` correspondiente. Usar al menos un estilo en los `layouts XML`. ‚ùì

14. Uso de permisos con `Android 6.0` ‚úÖ

15. Creaci√≥n de `una paleta de colores propia` de la aplicaci√≥n, de modo que visualmente se pueda identificar la app a un estilo visual reconocible. ‚úÖ

16. Uso de un `modo de persistencia local` adem√°s de las `Preferences DataStore` (tambi√©n obligatorio). Entre las opciones de persistencia local, se permitir√°n tanto almacenamiento en base de datos exclusivamente (`Room`) como frameworks que aporten esa soluci√≥n (`como Firebase por ejemplo`) ‚ùì

17. Uso de `ConstraintLayout`, `ViewPager` y `SwipeRefreshLayout`. ‚ùì

18. Realizaci√≥n de `peticiones web`: ya sea servicios `REST` con `Volley` o `Retrofit` o con `APIs` que se encarguen de `encapsular peticiones` como podr√≠a ser con `Amazon Web Services` por ejemplo. ‚ùì

19. Subir la aplicaci√≥n a `Google Play` (aunque sea en fase alpha o beta e invitar a los profesores) ‚ùì

## INICIO PROYECTO
Creo la aplicaci√≥n `TheSimpsonPlace` con una vista `Empty Activity` de `Jetpack Compose`.

1. Creaci√≥n de una `paleta de colores propia de la aplicaci√≥n`, de modo que visualmente se pueda identificar la app a un estilo visual reconocible. Ficheros `Color.kt` y `Theme.kt`. ‚úÖ

2. Los `textos, dimensiones, colores y estilos` deben residir en su `fichero de recursos` correspondiente. Usar al menos un estilo en los `layouts XML`. ‚ùå

3. `Esqueleto` del proyecto.
- Carpeta `data`: service, datasource, mapper....
- Carpeta `domain`: repository, usecases...
- Carpeta `presentation`: viewModels, views...

A√±adida las subcarpetas para la secci√≥n de personajes. Explicaci√≥n `1. DUDA.`

4. Instalaci√≥n de `dependencias` (de momento).
* 1. Serializaci√≥n: `kotlinx.serialization` para manejar `JSON`. (`@Serializable`). Utilizado por ejemplo a la hora de transformar la entidad `CharacterDto` recibida del json por otro nombres.
* 2. ConstraintLayout: `androidx.constraintlayout` y elegimos `constraintlayout-compose`. Para realizar en Compose (vistas).
* 3. ViewModel: `androidx.lifecycle` llamada `lifecycle-viewmodel-compose`. Descartamos versiones `alpha` coger la √∫ltima que no sea de este tipo. Para los ViewModels.
* 4. Navigation:  navigation compose. `androidx.navigation`.
* 5. Coil: `io.coil-kt` y aplicamos la de `coil-compose`. Carga de imaÃÅgenes de web.
* 6. Extensi√≥n de iconos: buscar `material-icons` obtener `material-icons-extended`.

5. A√±adir en el esqueleto (`punto 3.`) a aparte la que esta ya de personajes, las `secciones` de `episodio`, `citas` y `juego`.
En `1. DUDA`, explicado el esquema que he seguido para app (muy similar en personajes con las dem√°s secciones que ahora implemento).

Ejemplo con la `secci√≥n episodios`:



6. ...


### 1. Fichero `Color.kt`

Defino la paleta de colores para el estilo visual de mi app. Tanto en modo claro como modo oscuro.

```kotlin
// üé® Modo Oscuro
val BackgroundColor = Color(0xFF09184D)
val TextColor = Color(0xFFFFC107)
val BackgroundComponentColor = Color(0xFF4E5D9C)
val TextComponentColor = Color(0xFFFFFFFF)

// üé® Modo Claro
val BackgroundColorLight = Color(0xFF3B4D8B) // Azul m√°s claro que 0xFF09184D
val TextColorLight = Color(0xFFFFD54F) // Amarillo m√°s suave
val BackgroundComponentColorLight = Color(0xFF6F7ECF) // Azul m√°s claro que 0xFF4E5D9C
val TextComponentColorLight = Color(0xFF000000) // Negro (para contraste en claro)
```

### 2. Fichero `Theme.kt`

A√±ado los colores en los temas.
```kotlin
private val DarkColorScheme = darkColorScheme(
    primary = BackgroundColor, // Color principal
    secondary = BackgroundComponentColor, // Color para elementos secundarios
    background = BackgroundColor, // Color de fondo de la app
    surface = BackgroundComponentColor, // Color de fondo de los componentes
    onPrimary = TextColor, // Color del texto sobre el color primario
    onSecondary = TextComponentColor, // Color del texto sobre el color secundario
    onBackground = TextComponentColor, // Color del texto sobre el fondo
    onSurface = TextComponentColor // Color del texto sobre los componentes
)

private val LightColorScheme = lightColorScheme(
    primary = BackgroundColorLight, // Color principal m√°s claro
    secondary = BackgroundComponentColorLight, // Color para elementos secundarios m√°s claro
    background = BackgroundColorLight, // Color de fondo de la app m√°s claro
    surface = BackgroundComponentColorLight, // Color de fondo de los componentes m√°s claro
    onPrimary = TextColorLight, // Color del texto sobre el color primario m√°s claro
    onSecondary = TextComponentColorLight, // Color del texto sobre el color secundario m√°s claro
    onBackground = TextComponentColorLight, // Color del texto sobre el fondo m√°s claro
    onSurface = TextComponentColorLight // Color del texto sobre los componentes m√°s claro
)

```

Desactivo los colores din√°micos, para usar exclusivamente los colores de `DarkColorScheme` y `LightColorScheme`

```kotlin
@Composable
fun TheSimpsonPlaceTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean =  false, // ‚ùå Desactiva los colores din√°micos, usar√° exclusivamente los colores de DarkColorScheme y LightColorScheme.
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

Ahora mi app tiene un `modo claro` con `tonos m√°s suaves`, diferenci√°ndose del `modo oscuro` sin perder `identidad visual`.



### 3. Fichero `Logger.kt`
El archivo Logger.kt define una `interfaz de logging` que proporciona m√©todos estandarizados para registrar mensajes en diferentes niveles de severidad (Verbose, Debug, Info, Warning, Error, Assert). Su prop√≥sito es `centralizar y simplificar el proceso de depuraci√≥n`, permitiendo que cualquier clase que la implemente pueda registrar logs sin repetir c√≥digo. Adem√°s, asigna autom√°ticamente `el nombre de la clase como etiqueta (tag)`, facilitando la identificaci√≥n del origen de cada mensaje en Logcat.

### 4. Fichero ...
ME QUEDAN IMPLEMENTAR PARA LOS OTROS SECCIONES, REPASAR LAS CLASES DE ROBERTO, PASAR A REALIZAR LAS PANTALLAS BONITAS.

### X. MIS DUDAS

#### 1. DUDA ‚úÖ
@@@@ DUDA @@@@
Tengo mis dudas al intentar formar mi aplicaci√≥n (`3.`):
En cuanto al esqueleto de mi aplicaci√≥n: tengo 3 carpetas principales `data`, `domain` y `presentation`.

* Carpeta `Data`: de momento contiene:

- La subcarpeta `entities` a `CharacterDao.kt` (datos de com recibo una entidad del json de characters), `ImagenDto.kt` (datos de como recibo una entidad del json de imagenes), `Gender.kt` (enumerado con funci√≥n para pasar de string a ese enumerado).

- La subcarpeta `mapper` donde tengo `CharacterMapper.kt` con una extensi√≥n para pasar de `CharacterDto` a `Character` que es como trabajare en el domain.

- La subcarpeta `sources` la cual no se si esto es adecuado pero he hecho es dividir en dos carpetas:

+ Una subcarpeta `local` donde mi idea es obtener `los personajes del json` donde tengo un `CharacterDao.kt` con la `interface` y tiene `una funci√≥n` de obtener todos personajes (**voy a necesitar `otra funci√≥n` para filtrar por nombres de personajes pero no se si es adecuado incluirla aqui o mas adelante**).
`CharacterDaoJsonProd.kt` y `CharacterDaoJsonTest.kt` son dos de las implemanciones de la interface para obtener la funcion de los personajes.

+ Una subcarpeta `db` con lo mismo pero con la interface `CharacterDBDao.kt` y las funciones que tiene para los `characters` pero de en la `BD` y su correspondiente implementaci√≥n. **¬øEsta bien separarlos en dos `daos` diferentes? Uno con la l√≥gica deo obbtenci√≥n de datos y el otro con la de la BD o hay una mejor estructura?**

* La carpeta `domain` que de momento contiene:

- La subcarpeta `entities` con `Character.kt` que es el la entidad de personaje final con la que quiero trabajar tanto para la base de datos como la extraccion principal de los datos.

- La subcarpeta `repository` donde solo tengo una `interface` con el `CharacterRepository` con todas las funciones tanto del `dao` del `json` como para la del `dao` de la `base de datos` y he a√±adido `la nueva funci√≥n para filtrar por nombre` los personajes que se obtienen del json (no se la puse en el dao del json) **¬øEsta bien ponerla aqui o mejor era antes en el dao o despu√©s mas adelante ya en el view model?** Luego tengo la implentaci√≥n de ese dao `CharacterRepositoryImpl.kt` donde paso por paremetro las interfaces de los dos daos anteriores e implemento el `CharacterRepository`, aqui me surge otra vez **la duda al implementarse la funci√≥n de `filterCharacters` de filtrar los personajes tendria que realizar toda la funci√≥n de obtener todos los personajes y luego filtrarlo algo que no se si es buen en rendimiento por ello no se si deber√≠a estar.**

- La subcarpeta `usescases`: tengo todos los casos de uso de la interface `CharaterRepository.kt`, cada uno en una interfaz diferente y una carpeta `impl` con la implementaci√≥n de cada caso de uso pasandoloe por par√°metro el `CharaterRepository.kt`.

* La carpeta `presentation`: de momento solo esta creada dicha carpeta.
- La subcarpeta `ui` contiene a su vez
+ La subcarpeta `components` con vistas reutilizables en varias vistas principales como `BottomBar`, `TopBar` o `Icono dinamico` dependiendo de una variable por par√°metro.
+ La subcarpeta `screens` con otras carpetas donde divido la carpeta por secciones chracter, episode, menu, profile y quote. Tambien tiene el fichero de la actividad principal y unica de la aplicaci√≥n y un fichero Navegation el cual es una vista con toda la navegacion de la aplicaci√≥n (es la vista que se pasa  a la actividad).
+ La subcarpeta `themes` con los ficheros de configuraci√≥n de color, tema, tipografia...
+ La subcarpeta `viewmodel` donde de momento no hay anda pero se encontraran los ficheros de estaod d ela interfaz junto los view models de cada seccion de vistas.

* La carpete `utils` seperada de las tres capas de la aplicaci√≥n de momento solo tengo una inteerfaz `Logger.kt` con los posibles logger de la aplicaci√≥n. **¬øQue te parece la distribuci√≥n de los casos de uso en la capa del `domain`, y el esquema de capa de `presentacion`? Que me recomiendas cambiar o esta bien como esta? Es mi primera app y quiero tener una arquitectura lo mas clara, escalable y manenible posible.**

@@@@ SOLUCI√ìN GHAT GPT @@@@
Tu estructura `Data - Domain - Presentation` est√° bien planteada y sigue las mejores pr√°cticas de `Clean Architecture` en `Kotlin` con `Jetpack Compose`.

üìå 1. Estructura en la capa `data`

Actualmente tienes:
‚Ä¢ entities/ ‚Üí CharacterDto, ImageDto, Gender ‚úÖ Bien.
‚Ä¢ mappers/ ‚Üí CharacterMappers ‚úÖ Bien.
‚Ä¢ sources/local/ ‚Üí CharacterDao, CharacterDaoImpl üõë
‚Ä¢ sources/db/ ‚Üí CharacterDBDao, CharacterDBDaoImpl üõë

üîπ ¬øEst√° bien separar `DAO` del `JSON` y `DAO` de la `BD`?
‚úÖ S√≠, est√° bien porque:
1.	El JSON no es una BD real, solo es una fuente de datos est√°tica.
2.	`Separar responsabilidades` evita que `ambas fuentes` se mezclen en una misma clase.
3.	Si en el futuro usas Retrofit en vez de JSON local, el Dao del JSON ya no ser√≠a necesario.

üöÄ Mejora: **Puedes renombrar `CharacterDao.kt` ‚Üí `CharacterJsonSource.kt` y `CharacterDBDao.kt` ‚Üí `CharacterDatabaseSource.kt` para que quede m√°s claro.**

üìå 2. Estructura en la capa `domain`

Actualmente tienes:
‚Ä¢ entities/ ‚Üí Character ‚úÖ Bien.
‚Ä¢ repository/
    ‚Ä¢ CharacterRepository (interfaz) üõë
    ‚Ä¢ impl/ ‚Üí CharacterRepositoryImpl (implementaci√≥n) üõë
‚Ä¢ usecases/ ‚Üí Cada caso de uso en una interfaz distinta
	‚Ä¢ impl/ ‚Üí Implementaci√≥n de cada caso de uso pasando CharacterRepository

üîπ ¬øD√≥nde debe ir `filterCharacters(nombre)`?
üî∏ Si es un `simple filtro` sobre la lista obtenida, puede estar en `RepositoryImpl.kt`.
üî∏ Si en `el futuro la API` permite filtrar, deber√≠a ir en `CharacterJsonSource.kt` para no cargar la app de datos innecesarios.

üöÄ Mejora recomendada: **Si el `JSON nunca cambiar√°` ‚Üí d√©jalo en `RepositoryImpl.kt`. Pero si el `JSON es una API` o puede llegar a serlo en el futuro puede `permitir filtrar` ‚Üí Ponlo en `CharacterJsonSource.kt`.**

‚ùó Rendimiento
Si la lista de personajes es grande, filtrar despu√©s de cargar no es √≥ptimo. En ese caso, es mejor:
1.	Cargar solo los que coincidan ‚Üí Implementa `filterCharacters(name: String)` en `CharacterJsonSource.kt`.
2.	Guardar personajes en `BD local` y aplicar `filtros all√≠`.

üìå Casos de uso
‚úÖ Puntos positivos
‚úîÔ∏è Separaci√≥n clara de la l√≥gica de negocio.
‚úîÔ∏è Cumple el `principio de responsabilidad √∫nica` (cada caso de uso hace una sola cosa).
‚úîÔ∏è Permite `testear` cada caso de uso de `forma independiente`.

üìå 3. Estructura en `presentation`

Actualmente tienes:
‚Ä¢ üìÇ components/ ‚Üí Vistas reutilizables ‚úÖ
‚Ä¢ üìÇ screens/ ‚Üí Divisi√≥n por secciones ‚úÖ
‚Ä¢ üìÇ themes/ ‚Üí Colores, tipograf√≠a, etc. ‚úÖ
‚Ä¢ üìÇ viewmodel/ ‚Üí (A√∫n vac√≠o, pero pensado para ViewModels) ‚úÖ

‚úÖ Puntos positivos
‚úîÔ∏è Buena separaci√≥n de responsabilidades.
‚úîÔ∏è Divisi√≥n clara de screens por secciones.
‚úîÔ∏è Uso de components para evitar c√≥digo duplicado.
‚úîÔ∏è Carpeta themes bien ubicada.

‚ö†Ô∏è Posibles mejoras
üìå 1. Mover Navegation a una carpeta navigation/ dentro de presentation/ui
‚Ä¢ La navegaci√≥n no es exactamente una screen, sino una estructura que maneja las pantallas.
‚Ä¢ Crear üìÇ ui/navigation/ ‚Üí Mover Navegation.kt all√≠.

üìå 2. La actividad principal en una carpeta root/ dentro de presentation/ui
‚Ä¢ üìÇ ui/root/ ‚Üí MainActivity.kt
‚Ä¢ üìå Esto deja screens/ solo con pantallas reales y mejora la organizaci√≥n.

üìå 3. ViewModels bien organizados en viewmodel/
‚Ä¢ üìÇ viewmodel/character/CharacterViewModel.kt
‚Ä¢ üìÇ viewmodel/episode/EpisodeViewModel.kt
‚Ä¢ üìÇ viewmodel/profile/ProfileViewModel.kt
‚Ä¢ üìå Esto ayuda a encontrar r√°pidamente el ViewModel de cada secci√≥n.

üìå 4. Estructura en `utils`

Actualmente tienes:
	‚Ä¢	üìÇ utils/ ‚Üí Logger.kt

‚úÖ Puntos positivos
‚úîÔ∏è Centraliza funciones reutilizables.

‚ö†Ô∏è Posibles mejoras
üìå Si Logger.kt solo se usa en data, tal vez deber√≠a ir en data/utils/.
üìå Si utils/ tendr√° m√°s funciones reutilizables (como extensiones de Strings, Dates, etc.), entonces est√° bien en root/utils/.

üéØ Conclusi√≥n
‚úÖ Tu arquitectura est√° bien, solo hay que ajustar algunas responsabilidades.
‚úÖ S√≠, es correcto separar el DAO del JSON y el de la BD.
‚úÖ Filtrar personajes en el RepositoryImpl est√° bien, pero si el JSON puede filtrar, mejor en CharacterJsonSource.
‚úÖ Si tienes una BD, filtrar all√≠ es mejor por rendimiento.

üöÄ Recomendaciones finales:
üîπ Renombrar CharacterDao ‚Üí CharacterJsonSource y CharacterDBDao ‚Üí CharacterDatabaseSource.
üîπ Si el JSON es est√°tico, filtrar en RepositoryImpl.
üîπ Si es API, filtrar en CharacterJsonSource.
üîπ Si usas BD local, filtrar en la base de datos.
‚úîÔ∏è En domain: Usar clases de un solo m√©todo en vez de interfaces para los casos de uso.
‚úîÔ∏è En presentation: Mover Navegation.kt a navigation/ y MainActivity.kt a root/.
‚úîÔ∏è En viewmodel/: Organizar los ViewModels en subcarpetas por secciones.
‚úîÔ∏è En utils/: Mantenerlo solo si tendr√° m√°s funcionalidades reutilizables.

### 2. DUDA ‚úÖ
@@@@ DUDA @@@@
Debe solo tener una implementaci√≥n de `CharacterDao` para ficheros json, mediante una variable que se pase el json por par√°metro para saber si es el `json de test` o de `producci√≥n`? Ese parametro deve de ser `val` o no?

@@@@ SOLUCI√ìN GHAT GPT @@@@
üìå 1. Sobre el uso de `val json: String`

En este caso, s√≠ es correcto usar `val json: String` en el constructor, porque:
‚úÖ Es un `dato inmutable` ‚Üí Una vez que pasas el json, no cambiar√°.
‚úÖ Hace `la clase m√°s reutilizable` ‚Üí Puedes usar un JSON diferente para `testing` y `producci√≥n`.

üìå Cu√°ndo usar `val` en `par√°metros del constructor`
1. ‚úÖ SI USAR `val` ‚Üí Si el par√°metro se usar√° `dentro de la clase` como una `propiedad`.

```kotlin
    class CharacterDaoJson(val json: String) // Se usa dentro de la clase
```

2. ‚ùå NO USAR val ‚Üí Si solo se pasa como argumento y no necesitas guardarlo en la clase.
```kotlin
    class CharacterDaoJson(json: String) { // json NO se guarda en la clase
        fun getAllCharacters(): List<CharacterDto> {
            val data = json // Aqu√≠ lo usas solo dentro de la funci√≥n
            return listOf() // L√≥gica de parsing
        }
    }
```

En tu caso, como `json es una propiedad que usar√°s en m√∫ltiples funciones`, debe ser `val`.

### 3. DUDA ‚úÖ
@@@@ DUDA @@@@
Ahora voy a tener que tener la `entidad episodio` pero hay `dos variables nuevas` (ambas para la `base de datos` son booleanos que dicen si es visto y si es favorito el episodio) entonces no se que es mejor **crear `otra entidad nueva EpisodeDb` (y donde ponerle en este caso) o `modificar la entidad Episode` y que contenga esos `dos valores nuevos` a false por defecto** y asi utilizar la misma entidad tanto en con los datos normales como cuando se trabaja con la base de datos.

@@@@ RESPUESTA GHAT GPT @@@@
¬øDebe haber una `nueva entidad EpisodeDb` o `modificar Episode`?
Tienes dos opciones:
1.	Usar la misma entidad Episode y agregar las variables esVisto y esFavorito con un valor por defecto (false).
2.	Crear EpisodeDb como una entidad diferente exclusiva para la base de datos.

¬øCu√°l es la mejor opci√≥n?
‚úÖ Si la app siempre necesita manejar esVisto y esFavorito, lo mejor es mantener una √∫nica entidad Episode y establecer esos valores por defecto en false.
‚úÖ Si esVisto y esFavorito solo son relevantes en la base de datos, es mejor crear EpisodeDb y usar un mapper para convertir Episode <-> EpisodeDb.

@@@@ DUDA @@@@
Respuesta a: si `esVisto` y `esFavorito` son importantes en toda la app, agr√©galos a `Episode`.
Respecto a eso, mi idea es que en una `vista` tenga el `total de episodios` (obtenidos del json) con sus datos y `un icono` en un estado diferente dependiendo de si estan en `favoritos` y `visibles` o no (obtenido de la base de datos) y que se puede desde esa misma pantalla a√±adir a favoritos o no y dicha pantalla se actualice, lo idea es que **no tuviera que renderizarse todo el listado de nuevo solo el elemento de episodio que cambie de estado al ser de favortio o visto (dependiendo del icono pulsado)**.

@@@@ RESPUESTA GHAT GPT @@@@
El objetivo es mostrar todos los episodios obtenidos del JSON, pero que los episodios marcados como esFavorito y esVisto se actualicen desde la Base de Datos (sin recargar toda la lista). Adem√°s, si el usuario cambia uno de estos estados desde la interfaz, solo el episodio afectado debe actualizarse.

En el repositorio, al obtener los episodios desde el JSON, hay que cruzar los datos con la BD para verificar cu√°les est√°n en favoritos y vistos: ‚ö†Ô∏è‚õîÔ∏è
```kotlin
override fun getAllEpisodes(): List<Episode> {
    val episodesFromJson = episodeDaoJson.getAllEpisodes().map { it.toEpisode() }
    val favoriteEpisodes = episodeDaoDb.getFavoriteEpisodes() // Solo IDs marcados como favoritos
    val watchedEpisodes = episodeDaoDb.getWatchedEpisodes()   // Solo IDs marcados como vistos

    return episodesFromJson.map { episode ->
        episode.copy(
            esFavorito = favoriteEpisodes.any { it.id == episode.id },
            esVisto = watchedEpisodes.any { it.id == episode.id }
        )
    }
}
```

En el View Model:
```kotlin
class EpisodesViewModel(private val repository: EpisodesRepository) : ViewModel() {
    private val _episodes = MutableStateFlow<List<Episode>>(emptyList())
    val episodes: StateFlow<List<Episode>> = _episodes

    init {
        loadEpisodes()
    }

    private fun loadEpisodes() {
        viewModelScope.launch {
            _episodes.value = repository.getAllEpisodes()
        }
    }

    fun toggleFavorite(id: String) {
        viewModelScope.launch {
            repository.updateFavoriteStatus(id)
            _episodes.value = _episodes.value.map { ep ->
                if (ep.id == id) ep.copy(esFavorito = !ep.esFavorito) else ep
            }
        }
    }

    fun toggleWatched(id: String) {
        viewModelScope.launch {
            repository.updateWatchedStatus(id)
            _episodes.value = _episodes.value.map { ep ->
                if (ep.id == id) ep.copy(esVisto = !ep.esVisto) else ep
            }
        }
    }
}
```

En la UI con LazyColumn y actualizaci√≥n eficiente
```kotlin
@Composable
fun EpisodesScreen(viewModel: EpisodesViewModel) {
    val episodes by viewModel.episodes.collectAsState()

    LazyColumn {
        items(episodes) { episode ->
            EpisodeItem(episode, viewModel::toggleFavorite, viewModel::toggleWatched)
        }
    }
}

@Composable
fun EpisodeItem(episode: Episode, onFavClick: (String) -> Unit, onWatchedClick: (String) -> Unit) {
    Row(modifier = Modifier.fillMaxWidth().padding(8.dp)) {
        Text(text = episode.titulo, modifier = Modifier.weight(1f))

        IconButton(onClick = { onFavClick(episode.id) }) {
            Icon(
                imageVector = if (episode.esFavorito) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,
                contentDescription = "Favorito"
            )
        }

        IconButton(onClick = { onWatchedClick(episode.id) }) {
            Icon(
                imageVector = if (episode.esVisto) Icons.Filled.Check else Icons.Outlined.CheckBoxOutlineBlank,
                contentDescription = "Visto"
            )
        }
    }
}
```

### 4. DUDA
@@@@ DUDA @@@@
Respecto a la `implementaci√≥n (en kotlin) del repositorio de episodios` dada en la `Duda 3`.
Seria algo extra√±o estoy teniendo que hacer cada vez que se obtiene o filtra unos episodios del json comprobar a su vez si est√°n en la BD para darles los valores `esVisto` y `esFav` a true o false, esto **¬øno creo que `merma mucho el rendimiento` o no es asi? ¬øHay alguna l√≥gica mejor para hacer esto?**

@@@@ RESPUESTA GHAT GPT @@@@
S√≠, tu implementaci√≥n funciona correctamente, pero hay `un problema de rendimiento` al estar consultando toda la base de datos cada vez que obtienes episodios del JSON.

‚úÖ Problema actual
‚Ä¢ Cada vez que obtienes episodios del JSON, descargas todos los episodios de la BD (fetchAllEpisodes()).
‚Ä¢ Luego, filtras en memoria cu√°les son esFavorito y esVisto con `.any { it.id == episode.id }`, lo que puede ser ineficiente si hay muchos episodios.

üî• Mejor soluci√≥n: Consultas optimizadas a la BD

üí° Optimizaci√≥n clave:
üëâ En lugar de traer toda la BD, consulta solo los IDs necesarios.

En una BD a√±adir la funcionalidad de obtener episodios por array de ids:
```kotlin
@Dao
interface EpisodeDatabaseDao {
    @Query("SELECT * FROM episodes WHERE id IN (:ids)")
    fun fetchEpisodesByIds(ids: List<String>): List<Episode>
}
```

üõ†Ô∏è 1. Optimizar el acceso a la BD en getAllEpisodes()
```kotlin
override fun getAllEpisodes(): List<Episode> {
    val allEpisodesDto: List<EpisodeDto> = dao.getAllEpisodes()
    val allEpisodes: List<Episode> = allEpisodesDto.map { it.toEpisode() }
    val ids = allEpisodes.map { it.id } // Solo obtener los IDs de los episodios del JSON

    val episodesFromDb: Map<String, Episode> = daoDb.fetchEpisodesByIds(ids).associateBy { it.id }

    return allEpisodes.map { episode ->
        val episodeDb = episodesFromDb[episode.id] // Buscar solo el episodio en la BD por el id
        episode.copy(
            esFavorito = episodeDb?.esFavorito ?: false,
            esVisto = episodeDb?.esVisto ?: false
        )
    }
}
```

üõ†Ô∏è 2. Optimizar getEpisodeById(id: String)
No hace falta traer toda la BD, consulta solo el episodio:
```kotlin
override fun getEpisodeById(id: String): Episode? {
    val episodeDto: EpisodeDto? = dao.getEpisodeById(id)
    val episode = episodeDto?.toEpisode()
    val episodeDb = daoDb.fetchEpisodeById(id)

    return episode?.copy(
        esFavorito = episodeDb?.esFavorito ?: false,
        esVisto = episodeDb?.esVisto ?: false
    )
}
```

üõ†Ô∏è 3. Optimizar getEpisodesByTitle(title: String)
Misma l√≥gica de getAllEpisodes(), pero solo para los episodios con el t√≠tulo buscado.

üìå Resumen final üöÄ
üîπ ANTES: Descargabas toda la BD y filtrabas en memoria.
üîπ AHORA: Solo consultas los episodios necesarios directamente en la BD.
üîπ BENEFICIO: C√≥digo m√°s eficiente, evita procesos innecesarios y mejora el rendimiento en listas grandes.

### 5. DUDA ‚úÖ
@@@@ DUDA @@@@
Como verias en vez de crear **dos dao `EpisodeDao.kt` y `EpisodeDatabaseDao.kt`, juntar los dos en una √∫nica interfaz con todas las funciones** y luego que la implementaci√≥n ya contenga todas las acciones.

@@@@ RESPUESTA GHAT GPT @@@@
¬øEs buena idea unir `EpisodeDao` y `EpisodeDatabaseDao` en una sola interfaz?

‚ùå `No` es recomendable unirlos en una sola interfaz, porque est√°s mezclando `dos fuentes de datos diferentes`:
‚Ä¢ `getAllEpisodes()` ‚Üí Obtiene episodios del `JSON o API`.
‚Ä¢ `getAllEpisodesDb()` ‚Üí Obtiene episodios de la `BD (Room, Firebase, etc.)`.

Esto rompe el `Principio de Responsabilidad √önica (SRP)` y hace que el `EpisodeDaoJsonRoom` tenga dos responsabilidades distintas en la misma clase.

üî• Mejor alternativa: Separar en EpisodeRemoteDataSource y EpisodeLocalDataSource

üí° 1Ô∏è‚É£ Crear dos interfaces separadas
Mant√©n una para la `API/JSON` y otra para la `BD`, as√≠ no mezclas responsabilidades.

üí° 2Ô∏è‚É£ Implementar las interfaces separadas
üìå Implementaci√≥n de la API/JSON
üìå Implementaci√≥n de la BD (Room)

üìå Conclusi√≥n
üöÄ Separar `EpisodeDao` en `EpisodeRemoteDataSource` y `EpisodeLocalDataSource` mejora:
‚úÖ Claridad: Cada fuente de datos tiene su propia l√≥gica.
‚úÖ Escalabilidad: Si en el futuro cambias `Room` por `Firebase`, solo modificas `EpisodeLocalDataSourceImpl`.
‚úÖ Mantenimiento: M√°s f√°cil de modificar sin afectar otras partes del c√≥digo.

### 6. DUDA
@@@@ DUDA @@@@
Y si en vez de combinar en el repositorio `los episodios de db` con los de `json` se realiza por `separado` y cada vez que se vea un elemento de episodio lo que haga sea llamar a la funci√≥n de ver si esta en la BD si esta ver su `estado de fav y visto` y seg√∫n ese mostrar de una forma u otra. Eso no seria m√°s correcto o mejor en rendimiento?

@@@@ RESPUESTA GHAT GPT @@@@
**¬øEs mejor unir los datos de la `BD y JSON en el repositorio` o `consultarlos al mostrarlos`?**
Tu pregunta tiene dos enfoques:
1Ô∏è‚É£ Opci√≥n actual (mezclar JSON y BD en el `repositorio`)
2Ô∏è‚É£ Opci√≥n alternativa (consultar la BD al mostrar cada episodio en la `UI`)

1Ô∏è‚É£ Opci√≥n actual: Unir los datos en el Repository
‚úÖ Ventajas
‚úî Consulta √∫nica a la BD ‚Üí No hay llamadas extra cada vez que se muestra un episodio.
‚úî Menos impacto en la UI ‚Üí La vista recibe los datos ya procesados.
‚úî Mejor rendimiento en listas grandes ‚Üí Evita m√∫ltiples accesos a la BD mientras el usuario navega.

‚ùå Desventajas
‚úñ Carga inicial m√°s lenta ‚Üí Se obtiene y fusiona todo de golpe.
‚úñ No es reactivo ‚Üí Si se actualiza la BD mientras ves la lista, la UI no se actualiza.

2Ô∏è‚É£ Opci√≥n alternativa: Consultar la BD al mostrar el episodio.
‚úÖ Ventajas
‚úî Carga inicial m√°s r√°pida ‚Üí No se hace la consulta a la BD hasta que la UI la necesita.
‚úî M√°s reactivo ‚Üí Si la BD cambia, la UI se actualiza din√°micamente.
‚úî Menos memoria usada ‚Üí No carga toda la informaci√≥n de la BD si el usuario no la necesita.

‚ùå Desventajas
‚úñ M√°s consultas a la BD ‚Üí Puede afectar el rendimiento en listas grandes.
‚úñ M√°s trabajo en la UI ‚Üí Cada elemento hace una consulta a la BD, aumentando el uso de recursos.

üöÄ Conclusi√≥n: ¬øQu√© opci√≥n es mejor?

üîπ Si tu lista de episodios es grande (m√°s de 50 elementos) ‚Üí Mejor unir los datos en el Repository.
üîπ Si necesitas que la UI reaccione en tiempo real a cambios en la BD ‚Üí Mejor consultar en la UI.
üîπ Si usas `Jetpack Compose con Flow o LiveData` en Room ‚Üí Puedes hacer que la UI se actualice autom√°ticamente sin necesidad de recargar la lista completa.

üî∏ Recomendaci√≥n h√≠brida: Cargar `los datos en el Repository` pero usar `Flow para actualizar la UI` si la BD cambia. üöÄ
La idea de esta soluci√≥n es combinar lo mejor de ambas estrategias:
‚Ä¢ Cargar los datos iniciales desde el Repository (para evitar consultas innecesarias en la UI).
‚Ä¢ Usar `Flow de Room` para que la `UI` se actualice autom√°ticamente cuando la BD cambie.

üí° Conceptos clave

üîπ 1. Flow y reactividad en Room
En lugar de hacer consultas manuales, `Room` permite exponer datos como `Flow`, lo que significa que cualquier cambio en la BD notificar√° autom√°ticamente a la UI.
```kotlin
@Dao
interface EpisodeDao {
    @Query("SELECT * FROM episodes")
    fun getAllEpisodesFlow(): Flow<List<EpisodeEntity>> // üöÄ Se actualizar√° autom√°ticamente si cambia la BD
}
```

üîπ 2. Cargar datos combinados en el Repository
El Repository se encargar√° de cargar los datos iniciales del JSON y luego escuchar cambios en la BD con Flow.
```kotlin
class EpisodeRepository(
    private val episodeDao: EpisodeDao, // BD
    private val apiService: EpisodeApi //JSON / API
) {

    fun getEpisodes(): Flow<List<Episode>> {
        return flow {
            // üöÄ 1Ô∏è‚É£ Cargar datos del JSON/API
            val apiEpisodes = apiService.getEpisodes().map { it.toEpisode() }
            emit(apiEpisodes) // Emitir episodios iniciales

            // üöÄ 2Ô∏è‚É£ Escuchar cambios en la BD en segundo plano
            episodeDao.getAllEpisodesFlow().collect { dbEpisodes ->
                val updatedEpisodes = apiEpisodes.map { apiEpisode ->
                    val episodeDb = dbEpisodes.find { it.id == apiEpisode.id }
                    apiEpisode.copy(
                        esVisto = episodeDb?.esVisto ?: false,
                        esFavorito = episodeDb?.esFavorito ?: false
                    )
                }
                emit(updatedEpisodes) // Emitir episodios con estados actualizados
            }
        }
    }
}
```

üîπ 3. Mostrar los datos en la UI usando collectAsState en Compose
En la UI, simplemente escuchamos el Flow y la lista se actualiza autom√°ticamente si cambia la BD.
```kotlin
@Composable
fun EpisodeListScreen(viewModel: EpisodeViewModel) {
    val episodes by viewModel.episodes.collectAsState(initial = emptyList()) // üöÄ Se actualiza solo

    LazyColumn {
        items(episodes) { episode ->
            Text(episode.titulo)
        }
    }
}
```

üöÄ Ventajas de esta soluci√≥n h√≠brida
‚úÖ Carga inicial r√°pida ‚Üí Los episodios se muestran antes de consultar la BD.
‚úÖ Reactivo y eficiente ‚Üí La UI solo se actualiza si la BD cambia, sin consultas innecesarias.
‚úÖ Buen rendimiento ‚Üí Flow gestiona los cambios sin necesidad de recargar la lista completa.

üìå Resumen
üí° El Repository obtiene los datos del JSON/API y emite la lista de episodios.
üí° Luego, usa Flow de Room para escuchar cambios en la BD y actualizar la UI sin necesidad de consultas extra.

### 7. DUDA
@@@@ DUDA @@@@
**Conceptos b√°sicos, 3 dudas**

@@@@ RESPUESTA GHAT GPT @@@@
1Ô∏è‚É£ `¬øQu√© hace copy en Kotlin?`
El m√©todo `copy()` se usa en las `data class` para crear una nueva instancia con los mismos valores de la original, pero permitiendo modificar solo algunos campos.

üìå ¬øPor qu√© se usa en tu c√≥digo?
Porque cuando combinas datos del JSON con la BD, la informaci√≥n de esFavorito y esVisto proviene de la BD, as√≠ que en lugar de modificar el objeto original, se genera una nueva copia con los valores actualizados.

```kotlin
data class Character(
    val id: Int,
    val name: String,
    val esFavorito: Boolean
)

fun main() {
    val character1 = Character(1, "Homer", false)
    val character2 = character1.copy(esFavorito = true) // Solo cambia "esFavorito"

    println(character1) // Character(id=1, name=Homer, esFavorito=false)
    println(character2) // Character(id=1, name=Homer, esFavorito=true)
}
```

2Ô∏è‚É£ `Optimizar la l√≥gica de combinaci√≥n de datos`
‚Ä¢ Actualmente en getAllCharacters() comparas la lista obtenida del JSON con la de la BD pero accediendo a la BD para cada elemento (allCharactersDB[character.id]).
‚Ä¢ Esto puede ser costoso en rendimiento, ya que est√°s haciendo N b√∫squedas en la BD (donde N es el n√∫mero de personajes) en vez de una sola operaci√≥n.
‚Ä¢ Soluci√≥n: Convertir allCharactersDB en un Set o Map para evitar b√∫squedas repetitivas.

Ambas formas que con `Set` o `Map` son similares, pero la segunda opci√≥n con Map<String, Episode> es m√°s eficiente. Y nunca por comparaci√≥n normal.
üìå ¬øPor qu√© es mejor?
‚Ä¢ B√∫squeda r√°pida: associateBy crea un Map<String, Episode>, lo que permite acceder por id en O(1) en lugar de hacer b√∫squedas repetitivas en una lista (O(n)).
‚Ä¢	Estructura clara: La BD solo se consulta una vez y no en cada iteraci√≥n.

Para mejorar la eficiencia de la funci√≥n, en lugar de usar un `Set` para almacenar los id de los personajes favoritos, podemos utilizar un `Map<Int, Character>` para acceder r√°pidamente a los personajes favoritos con sus datos completos. Esto permite extender f√°cilmente el proceso si en el futuro se agregan m√°s atributos desde la BD.

```kotlin
override fun getAllCharacters(): List<Character> {
    // üöÄ 1Ô∏è‚É£ Cargar datos del JSON/API
    val allCharactersDto = dao.getAllCharacters()
    val allCharacters = allCharactersDto.map { it.toCharacter() }

    // üöÄ 2Ô∏è‚É£ Obtener los personajes favoritos de la BD y convertirlos en un Set para b√∫squeda r√°pida
    val favoriteCharacterIds = databaseDao.getAllCharactersDb().map { it.id }.toSet()

    // üöÄ 3Ô∏è‚É£ Retornar lista fusionada sin hacer m√∫ltiples b√∫squedas
    return allCharacters.map { character ->
        character.copy(esFavorito = favoriteCharacterIds.contains(character.id))
    }
}
```

Pasamos a:
```kotlin
override fun getAllCharacters(): List<Character> {
    // üöÄ 1Ô∏è‚É£ Obtener todos los personajes del JSON/API y mapearlos a la entidad `Character`
    val allCharactersDto = dao.getAllCharacters()
    val allCharacters = allCharactersDto.map { it.toCharacter() }

    // üöÄ 2Ô∏è‚É£ Obtener los personajes favoritos de la BD y convertirlos en un Map para acceso r√°pido
    val favoriteCharactersMap = databaseDao.getAllCharactersDb().associateBy { it.id }

    // üöÄ 3Ô∏è‚É£ Fusionar datos del JSON con la BD (si el personaje est√° en la BD, tomar `esFavorito` de ah√≠)
    return allCharacters.map { character ->
        val characterDb = favoriteCharactersMap[character.id] // Buscar personaje en la BD
        character.copy(
            esFavorito = characterDb?.esFavorito ?: false // Si est√° en la BD, usar su estado real
        )
    }
}
```

üìå ¬øPor qu√© esta versi√≥n es mejor?
‚úî Acceso r√°pido a los datos de la BD: `associateBy { it.id }` convierte la lista de la BD en un Map<Int, Character>, lo que permite b√∫squedas O(1) en lugar de O(n).
‚úî Facilidad de ampliaci√≥n: Si en el futuro se necesitan m√°s datos de la BD, solo hay que modificar `copy()`.
‚úî Menos iteraciones innecesarias: No se necesita recorrer la lista de la BD varias veces para verificar `esFavorito`, ya que el Map permite un acceso directo.

3Ô∏è‚É£ `Usar suspend en las operaciones de la BD`
‚Ä¢ Las operaciones de BD deber√≠an ejecutarse en un coroutineScope, ya que son operaciones de I/O y pueden bloquear el hilo principal si no son suspendidas.
‚Ä¢ insertCharacterDb() y deleteCharacterDb() deben ser suspend.

```kotlin
interface CharaterRepository {
    fun getAllCharacters(): List<Character>
    fun getCharactersByName(name: String): List<Character>

    fun getAllCharactersDb(): Flow<List<Character>> // üöÄ Flow para cambios en tiempo real
    suspend fun insertCharacterDb(character: Character)
    suspend fun deleteCharacterDb(id: Int)
}
```

```kotlin
override suspend fun insertCharacterDb(character: Character) {
    databaseDao.insertCharacterDb(character)
}

override suspend fun deleteCharacterDb(id: Int) {
    databaseDao.deleteCharacterDb(id)
}
```